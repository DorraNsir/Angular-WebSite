{
  "posts": [
    {
      "id": 13,
      "nom": "popo",
      "prenom": "momo",
      "photo": "assets/images/logo2.jpg",
      "blogPost": "aaaaaaaaaaaaaaaaaaaaaaa"
    },
    {
      "id": 25,
      "nom": "aaaa",
      "prenom": "aaaaa",
      "photo": "assets/images/avatar4.jpg",
      "blogPost": "aaaa"
    },
    {
      "id": 26,
      "nom": "samira",
      "prenom": "Ben ahmd",
      "photo": "assets/images/avatar4.jpg",
      "blogPost": " creation of Node.js in 2009 by Ryan Dahl sparked a significant increase in the usage of JavaScript outside of web browsers. Node combines the V8 engine, an event loop, and I/O APIs, thereby providing a stand-alone JavaScript runtime system.[27][28] As of 2018, Node had been used by millions of developers,[29] and npm had the most modules of any package manager in the world.[30]\n\nThe ECMAScript draft specification is currently[as of?] maintained openly on GitHub, and editions are produced via regular annual snapshots.[31] Potential revisions to the language are vetted through a comprehensive proposal process.[32][33] Now, instead of edition numbers, developers check the status of upcoming features individually.[31]\n\nThe current JavaScript ecosystem has many libraries and frameworks, established programming practices, and substantial usage of JavaScript outside of web browsers. Plus, with the rise of single-page applications and other JavaScript-heavy websites, several transpilers have been created to aid the development process"
    },
    {
      "id": 27,
      "nom": "nsir",
      "prenom": "dorra",
      "photo": "assets/images/avatar2.jpg",
      "blogPost": "JavaScript typically relies on a run-time environment (e.g., a web browser) to provide objects and methods by which scripts can interact with the environment (e.g., a web page DOM). These environments are single-threaded. JavaScript also relies on the run-time environment to provide the ability to include/import scripts (e.g., HTML <script> elements). This is not a language feature per se, but it is common in most JavaScript implementations. JavaScript processes messages from a queue one at a time. JavaScript calls a function associated with each new message, creating a call stack frame with the function's arguments and local variables. The call stack shrinks and grows based on the function's needs. When the call stack is empty upon function completion, JavaScript proceeds to the next message in the queue. This is called the event loop, described as \"run to completion\" because each message is fully processed before the next message is considered. However, the language's concurrency model describes the event loop as non-blocking: program input/output is performed using events and callback functions. This means, for instance, that JavaScript can process a mouse click while waiting for a database query to return information"
    }
  ],
  "comments": [],
  "profile": {
    "name": "typicode"
  }
}